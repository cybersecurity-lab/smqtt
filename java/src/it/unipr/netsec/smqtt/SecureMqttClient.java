package it.unipr.netsec.smqtt;

import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;

import org.zoolu.util.Bytes;
import org.zoolu.util.json.Json;
import org.zoolu.util.log.DefaultLogger;
import org.zoolu.util.log.LoggerLevel;

import it.unipr.netsec.smqtt.gkd.GKDClient;
import it.unipr.netsec.smqtt.gkd.KeyServer;
import it.unipr.netsec.smqtt.gkd.message.AuthenticatedEncryption;
import it.unipr.netsec.smqtt.gkd.message.JoinRequest;
import it.unipr.netsec.smqtt.gkd.message.JoinResponse;
import it.unipr.netsec.smqtt.gkd.method.SlottedGKDClient;
import it.unipr.netsec.smqtt.gkd.method.StaticGKDClient;
import it.unipr.netsec.smqtt.gkd.method.UpdateGKDClient;
import io.ipstack.mqtt.MqttClient;
import io.ipstack.mqtt.MqttClientListener;
import io.ipstack.mqtt.PahoClient;


/**
 * Enhanced MQTT client with end-to-end (E2E) security.
 * <p>
 * Published data is E2E authenticated and encrypted using a symmetric key.
 * In order to transparently work also with one-to-may communications,
 * natively supported by MQTT through the publish/subscribe paradigm, a group symmetric key is used. <br>
 * The group key is created and managed by a trusted Group Key Distribution Center (GKDC).
 * <p>
 * Three different group key distribution methods are currently supported:
 * <ul>
 * <li><i>STATIC</i> - For each group a static group key is generated by the GKDC and distributed to each authorized client
 * that requests to join the group. </li>
 * <li><i>UPDATE</i> - for each group a group key is distributed by the GKDC to authorized client. Each time a new client
 * requests to join the group, a new key is generated and distributed to all members of the group (including the previous
 * clients and the new client). <br>
 * Similarly, each time a member leaves the group, a new key is generated and distributed to all remaining members. </li>
 * <li><i>SLOTTED</i> - For each group a dynamic key is considered. Differently from the previous methods,
 * the time is divided in time slots, and for each time slot a different key is defined. <br>
 * In order to manage possible big numbers of time slots and corresponding keys, a dynamic auto-generating mechanism
 * is considered. The mechanism is similar to the one proposed in [1].</li>
 * </ul>
 * <p>
 * Regardless the selected group key distribution method, all key material exchanged between the GKDC and the MQTT clients
 * are protected using long-term secrets associated to the each client.
 * <p>
 * [1] L. Veltri et al, "A novel batch-based group key management protocol applied to the Internet of Things",
 * Ad Hoc Networks, Volume 11, Issue 8, November 2013, pages 2724-2737.
 */
public class SecureMqttClient implements MqttClient {

	/** Verbose mode */
	public static boolean VERBOSE= false;

	/** Debug mode */
	public static boolean DEBUG= false;

	private void log(String str) {
		DefaultLogger.log(LoggerLevel.INFO,null,this.getClass().getSimpleName()+"("+clientId+"): "+str);
	}
	
	
	public static int GKD_TYPE= 1; // 1=static, 2=update, 3=slotted
	
	String clientId;
	
	/** Long-term client secret key */
	byte[] clientKey;
	
	GKDClient gkdClient;
	
	private MqttClient mqttClient= null;
	
	MqttClientListener listener=null;
	

	/** Creates a new MQTT client.
	 * @param clientId client identifier
	 * @param clientKey client key
	 * @param broker MQTT broker
	 * @param listener client listener
	 * @throws IOException
	 */
	public SecureMqttClient(String clientId, byte[] clientKey, String broker, MqttClientListener listener) throws IOException {
		this(clientId,clientKey,broker,null,null,listener);
	}

	/** Creates a new MQTT client.
	 * @param clientId client identifier
	 * @param clientKey client key
	 * @param broker MQTT broker
	 * @param username username for connecting to the broker
	 * @param passwd password for connecting to the broker
	 * @param listener client listener
	 * @throws IOException
	 */
	public SecureMqttClient(String clientId, byte[] clientKey, String broker, String username, String passwd, MqttClientListener listener) throws IOException {
		this.listener= listener;
		this.clientId= clientId;
		this.clientKey= clientKey;
		mqttClient= new PahoClient(clientId,"tcp://"+broker,username,passwd,new MqttClientListener() {

			@Override
			public void onSubscribing(MqttClient client, String topic, int qos) {
				// TODO
				if (listener!=null) listener.onSubscribing(client,passwd,qos);
			}

			@Override
			public void onPublishing(MqttClient client, String topic, int qos, byte[] payload) {
				// TODO
				if (listener!=null) listener.onPublishing(client,passwd,qos,payload);
			}

			@Override
			public void onMessageArrived(MqttClient client, String topic, int qos, byte[] payload) {
				processReceivedMessage(topic,qos,payload);
			}

			@Override
			public void onConnectionLost(MqttClient client, Throwable cause) {
				// TODO
				if (listener!=null) listener.onConnectionLost(client,cause);
			}
		});
		
		switch (GKD_TYPE) {
			case 1: gkdClient= new StaticGKDClient(clientId,clientKey); break;
			case 2: gkdClient= new UpdateGKDClient(clientId,clientKey); break;
			case 3: gkdClient= new SlottedGKDClient(clientId,clientKey); break;
		}
		if (gkdClient==null) throw new IOException("unsupported GKD type: "+GKD_TYPE);
	}

	/** Joins a group.
	 * @param group group identifier
	 * @throws IOException
	 */
	public void join(String group) throws IOException {
		if (VERBOSE) log("join(): JOIN REQUEST: group="+group);
		gkdClient.join(group,(JoinRequest join)->{
			if (DEBUG||VERBOSE) log("join(): JOIN REQUEST: send: "+join.toJson());
			mqttClient.publish(KeyServer.TOPIC_GKD+"/"+GKD_TYPE+"/"+KeyServer.TOPIC_JOIN,KeyServer.DEFAULT_QOS,join.toJson().getBytes());
		});
	}

	/** Joins a group for a given time.
	 * @param group group identifier
	 * @param expires expiration time [secs]
	 * @throws IOException
	 */
	public void join(String group, int expires) throws IOException {
		if (VERBOSE) log("join(): JOIN REQUEST: group="+group+", expires="+expires);
		gkdClient.join(group,expires,(JoinRequest join)->{
			if (DEBUG||VERBOSE) log("join(): JOIN REQUEST: send: "+join.toJson());
			mqttClient.publish(KeyServer.TOPIC_GKD+"/"+GKD_TYPE+"/"+KeyServer.TOPIC_JOIN,KeyServer.DEFAULT_QOS,join.toJson().getBytes());
		});
	}

	/**
	 * @param topic
	 * @param payload
	 */
	private void processReceivedMessage(String topic, int qos, byte[] payload) {
		try {
			if (DEBUG) log("processReceivedMessage(): topic="+topic+", len="+payload.length);
			//if (DEBUG) log("processReceivedMessage(): topic="+topic+", len="+payload.length+", payload="+Bytes.toHex(payload));
			var topicPath= topic.split("/");
			if (topicPath[0].equals(KeyServer.TOPIC_GKD)) {
				if (!topicPath[1].equals(String.valueOf(GKD_TYPE))) throw new IOException("Wrong GKD type: "+topicPath[1]);
				if (!topicPath[2].equals(clientId)) throw new IOException("Wrong client id: "+topicPath[2]);
				// else
				var body= new String(payload);
				var joinResp= Json.fromJSON(body,JoinResponse.class);
				joinResp.verify(clientKey);
				//if (DEBUG||VERBOSE) log("processReceivedMessage(): JOIN RESPONSE: group="+joinResp.group+", expires="+joinResp.expires+"s, key-material="+joinResp.key);
				if (DEBUG||VERBOSE) log("processReceivedMessage(): JOIN RESPONSE: "+joinResp.toJson());
				if (DEBUG||VERBOSE) log("processReceivedMessage(): JOIN RESPONSE: key material: "+joinResp.getKeyMaterial(clientKey));
				gkdClient.handleJoinResponse(joinResp);					
			}
			else {
				var index= Bytes.toInt16(payload);
				payload= Bytes.copy(payload,2,payload.length-2);
				//if (DEBUG||VERBOSE) log("processReceivedMessage(): getGroupKey(): "+topic+","+index);
				var groupKey= gkdClient.getGroupKey(topic,index);
				if (groupKey==null) {
					if (DEBUG||VERBOSE) log("processReceivedMessage(): No valid group key found: message discarded");
					return;
				}
				// else
				if (DEBUG) log("processReceivedMessage(): group key: "+Bytes.toHex(groupKey));
				try {
					var cipher= new AuthenticatedEncryption(groupKey);
					var plaintext= cipher.decrypt(payload);
					if (DEBUG||VERBOSE) log("processReceivedMessage(): msg: "+(Bytes.isAscii(plaintext)? "'"+new String(plaintext)+"'" : Bytes.toHex(plaintext)));
					if (listener!=null) listener.onMessageArrived(this,topic,qos,plaintext);
				}
				catch (Exception e) {
					throw new IOException("SecureMqttClient("+clientId+"): processReceivedMessage(): Decryption error: possible wrong group key: "+Bytes.toHex(groupKey),e);
				}
			}
		}
		catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Override
	public void connect() throws IOException {
		mqttClient.connect();
		mqttClient.subscribe(KeyServer.TOPIC_GKD+"/+/"+clientId,KeyServer.DEFAULT_QOS);
	}

	@Override
	public void disconnect() throws IOException {
		mqttClient.disconnect();
	}

	@Override
	public String getBrokerUrl() {
		return mqttClient.getBrokerUrl();
	}

	@Override
	public String getId() {
		return mqttClient.getId();
	}

	@Override
	public void publish(String topic, int qos, byte[] payload) throws IOException {
		if (DEBUG||VERBOSE) log("publish(): topic="+topic+", msg: "+(Bytes.isAscii(payload)? "'"+new String(payload)+"'"  : Bytes.toHex(payload)));
		var indexKeyPair= gkdClient.getGroupKey(topic);
		if (DEBUG||VERBOSE) log("publish(): getGroupKey(): "+topic+","+indexKeyPair.index);
		if (indexKeyPair==null) {
			if (DEBUG||VERBOSE) log("publish(): No valid group key found: publishing failed");
			return;
		}
		if (DEBUG) log("publish(): group key: "+Bytes.toHex(indexKeyPair.key));
		try {
			//var cipher= new AuthenticatedEncryption(indexKeyPair.key);
			//byte[] ciphertext= cipher.encrypt(payload);
			//mqttClient.publish(topic,qos,Bytes.concat(Bytes.fromInt16(indexKeyPair.index),ciphertext));
			securePublish(topic,qos,indexKeyPair.key,indexKeyPair.index,payload);
		}
		catch (Exception e) {
			throw new IOException(e);
		}
	}

	@Override
	public void subscribe(String topicName, int qos) throws IOException {
		mqttClient.subscribe(topicName,qos);
		
	}
	
	private void securePublish(String topic, int qos, byte[] key, int index, byte[] payload) throws IOException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
		var cipher= new AuthenticatedEncryption(key);
		byte[] ciphertext= cipher.encrypt(payload);
		mqttClient.publish(topic,qos,Bytes.concat(Bytes.fromInt16(index),ciphertext));
	}

}
