package assist.smqtt.gkd;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.NoSuchAlgorithmException;

import org.zoolu.util.json.Json;
import org.zoolu.util.log.DefaultLogger;
import org.zoolu.util.log.LoggerLevel;

import assist.smqtt.gkd.message.JoinRequest;
import assist.smqtt.gkd.message.JoinResponse;
import assist.smqtt.gkd.method.SlottedGKDService;
import assist.smqtt.gkd.method.StaticGKDService;
import assist.smqtt.gkd.method.UpdateGKDService;
import io.ipstack.mqtt.MqttClient;
import io.ipstack.mqtt.MqttClientListener;
import io.ipstack.mqtt.PahoClient;


/**
 * Group Key Distribution Center (GKDC).
 * <p>
 * Three different group key distribution methods are currently supported:
 * <ul>
 * <li><i>STATIC</i> - For each group a static group key is generated by the GKDC and distributed to each authorized client
 * that requests to join the group. </li>
 * <li><i>UPDATE</i> - for each group a group key is distributed by the GKDC to authorized client. Each time a new client
 * requests to join the group, a new key is generated and distributed to all members of the group (including the previous
 * clients and the new client). <br>
 * Similarly, each time a member leaves the group, a new key is generated and distributed to all remaining members. </li>
 * <li><i>SLOTTED</i> - For each group a dynamic key is considered. Differently from the previous methods,
 * the time is divided in time slots, and for each time slot a different key is defined. <br>
 * In order to manage possible big numbers of time slots and corresponding keys, a dynamic auto-generating mechanism
 * is considered. The mechanism is similar to the one proposed in [1].</li>
 * </ul>
 * <p>
 * Regardless the selected group key distribution method, all key material exchanged between the GKDC and the MQTT clients
 * are protected using long-term secrets associated to the each client.
 * <p>
 * [1] L. Veltri et al, "A novel batch-based group key management protocol applied to the Internet of Things",
 * Ad Hoc Networks, Volume 11, Issue 8, November 2013, pages 2724-2737.
 */
public class GKDServer {

	/** Verbose mode */
	public static boolean VERBOSE= false;

	/** Debug mode */
	public static boolean DEBUG= false;

	private void log(String str) {
		DefaultLogger.log(LoggerLevel.INFO,this.getClass(),str);
	}


	public static String TOPIC_GKD= "gkd";
	public static String TOPIC_JOIN= "join";
	public static String TOPIC_LEAVE= "leave";
	public static int DEFAULT_QOS= 2;
	
	public static int KEY_LENGTH= 16; // 128 bits

	private StaticGKDService gkdService1= null; // type 1
	private UpdateGKDService gkdService2= null; // type 2
	private SlottedGKDService gkdService3= null; // type 3

	private MqttClient mqttClient= null;

	
	/** 
	 * @param serverId MQTT client ID of the server
	 * @param broker MQTT broker
	 * @throws IOException */
	public GKDServer(String serverId, String broker) throws IOException {
		this(serverId,broker,null,null);
	}

	/** 
	 * @param serverId MQTT client ID of the server
	 * @param broker MQTT broker
	 * @param username username for connecting to the broker
	 * @param passwd password for connecting to the broker
	 * @throws IOException */
	public GKDServer(String serverId, String broker, String username, String passwd) throws IOException {
		/*switch (GKD_METHOD) {
			case STATIC: gkdService= new StaticGKDService(); break;
			case UPDATE: gkdService= new UpdateGKDService(); break;
			case SLOTTED: try { gkdService= new SlottedGKDService(); } catch (NoSuchAlgorithmException|UnsupportedEncodingException e) { e.printStackTrace(); } break;
		}*/
		gkdService1= new StaticGKDService();
		gkdService2= new UpdateGKDService();
		try { gkdService3= new SlottedGKDService(); } catch (NoSuchAlgorithmException|UnsupportedEncodingException e) { e.printStackTrace(); }
		
		mqttClient= new PahoClient(serverId,"tcp://"+broker,username,passwd,new MqttClientListener() {

			@Override
			public void onSubscribing(MqttClient client, String topic, int qos) {
				// TODO Auto-generated method stub
			}

			@Override
			public void onPublishing(MqttClient client, String topic, int qos, byte[] payload) {
				// TODO Auto-generated method stub
			}

			@Override
			public void onMessageArrived(MqttClient client, String topic, int qos, byte[] payload) {
				processReceivedMessage(topic,payload);
			}

			@Override
			public void onConnectionLost(MqttClient client, Throwable cause) {
				// TODO Auto-generated method stub
			}
		});
		try {
			mqttClient.connect();
			mqttClient.subscribe(TOPIC_GKD+"/+/"+TOPIC_JOIN,DEFAULT_QOS);
		}
		catch (Exception e) {
			e.printStackTrace();
		}
	}

	/** Processes Join and Leave requests
	 * @param topic
	 * @param payload
	 */
	private void processReceivedMessage(String topic, byte[] payload) {
		try {
			var body= new String(payload);
			if (DEBUG) log("processReceivedMessage(): received: "+topic+" "+body);
			var topicFields= topic.split("/");
			if (!topicFields[0].equals(TOPIC_GKD)) {
				if (GKDServer.DEBUG||GKDServer.VERBOSE) log("processReceivedMessage(): not for key distribution: discarded");
				return;
			}
			GKDService gkdService= null;
			int type;
			try {
				type= Integer.parseInt(topicFields[1]);
				switch (type) {
					case 1: gkdService= gkdService1; break;
					case 2: gkdService= gkdService2; break;
					case 3: gkdService= gkdService3; break;
					default: throw new RuntimeException("Unsupported GKD type: "+type);
				}
			}
			catch (Exception e) {
				if (GKDServer.DEBUG||GKDServer.VERBOSE) log("processReceivedMessage(): wrong GKD type: "+topicFields[1]);
				return;				
			}
			if (topicFields[2].equals(TOPIC_JOIN)) {
				var joinReq= Json.fromJSON(body,JoinRequest.class);
				gkdService.handleJoinRequest(joinReq, (JoinResponse joinResp)->{
					try {
						if (GKDServer.DEBUG||GKDServer.VERBOSE) log("processReceivedMessage(): send key material to '"+joinResp.member+"' for group '"+joinResp.group+"': "+joinResp.key);
						mqttClient.publish(TOPIC_GKD+"/"+type+"/"+joinResp.member,DEFAULT_QOS,Json.toJSON(joinResp).getBytes());
					}
					catch (IOException e) {
						e.printStackTrace();
					}
				});
			}
			else if (topicFields[2].equals(TOPIC_LEAVE)) {
				// TODO
			}
		}
		catch (Exception e) {
			e.printStackTrace();
		}
	}

}
